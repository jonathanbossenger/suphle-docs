(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{834:function(e,t,n){"use strict";n.r(t);var o=n(73),a=Object(o.a)({},(function(){var e=this.$createElement,t=this._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("p",[this._v("##PLUGINS\nOur emphasis on decoupling means domain module authors are encouraged to build\naround standardized interfaces for decreased coupling. A sample library is a module\nwhose exports class must implement the library for the category it belongs\nto. For instance, paystack library implements the payment gateway module.\nIn the consuming module, we define Suphple payment gateway interface as one\nof the depends, and plug in paystack or flutterwave libraries in the provider")]),this._v(" "),t("p",[this._v("You can either have libraries giving new functionality to the developer or\nthose overriding default framework behaviour. For the latter to be\npossible, we have to operate with interfaces, load our own implementation\nduring boot, and pull them from the container.\nWe can either do this everywhere or at positions we intend leaving open for\nextension such as the object that boots controller arguments\nThe difference between both is that packages/libraries are framework\nagnostic. Or at least, they are meant to be. They ought to rely on language\nconstructs for implementing functionality. Plugins on the other hand, are\nfor replacing existing\nfunctionality in the framework")]),this._v(" "),t("p",[this._v("Doc readers want to know what classes are overridable")])])}),[],!1,null,null,null);t.default=a.exports}}]);